(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{340:function(v,_,t){"use strict";t.r(_);var s=t(18),p=Object(s.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"浅谈密码学"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#浅谈密码学"}},[v._v("#")]),v._v(" 浅谈密码学")]),v._v(" "),t("blockquote",[t("p",[v._v("本文为初学前端时所写，未进行勘误便移植了过来，若有错误请见谅。")])]),v._v(" "),t("h3",{attrs:{id:"前言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[v._v("#")]),v._v(" 前言")]),v._v(" "),t("p",[v._v("我已经有很久没有看过技术类的书籍了，着实是感到惭愧万分。密码学实在是博大精深，满是晦涩难懂的公式与算法。上次看相关的知识还是大概一年多以前，当初想着不求全部理解，至少要把一些常识性的知识点搞明白。免得出去啥也不会，实在是让人笑话。不过当时也没有写什么文章来记录，一是觉得自己本来就是学了点皮毛的东西，写出来只会贻笑大方；而且这东西要讲明白还是需要很多功夫的，所以也就作罢。最近学计网的时候，又要用到相关的知识点时，才发现脑子里只能勉强记得几个名词，深刻的东西却完全想不起来。这时候才感到人的记忆能力还是太不可靠，以后还是把各种东西都记录下来吧。于是重新翻书出来又看了一遍，然后用本文做一个简单的总结。")]),v._v(" "),t("p",[v._v("正如标题所说，本文只是简单的浅谈二字，加上笔者本身是个菜鸟，所以就不要希望看到什么高深的东西了。")]),v._v(" "),t("p",[v._v("本文大概算是一篇通识类的文章，或者说是科普吧，不过本文也无法保证谨慎，所以如果有错误希望指出。")]),v._v(" "),t("h3",{attrs:{id:"正文"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#正文"}},[v._v("#")]),v._v(" 正文")]),v._v(" "),t("p",[v._v("在我看来，密码学最重要的三个点")]),v._v(" "),t("ol",[t("li",[t("strong",[v._v("机密性")])])]),v._v(" "),t("p",[v._v("即保证通信的内容不会被第三者知晓。")]),v._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[t("strong",[v._v("完整性")])])]),v._v(" "),t("p",[v._v("即使能保证机密性，也要保证通信的内容没有被篡改过或丢失。")]),v._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[t("strong",[v._v("认证")])])]),v._v(" "),t("p",[v._v("即确认通信的对象并不是伪造的第三方。")]),v._v(" "),t("h4",{attrs:{id:"加密算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#加密算法"}},[v._v("#")]),v._v(" 加密算法")]),v._v(" "),t("p",[v._v("想要保证消息的机密性，就要使用合理的加密算法。")]),v._v(" "),t("p",[v._v("而加密算法根据使用的密钥的类型可以分为以下三种")]),v._v(" "),t("ol",[t("li",[t("strong",[v._v("对称加密算法")])]),v._v(" "),t("li",[t("strong",[v._v("非对称加密算法（公钥加密算法）")])]),v._v(" "),t("li",[t("strong",[v._v("混合加密算法")])])]),v._v(" "),t("p",[t("strong",[v._v("对称加密算法")])]),v._v(" "),t("p",[v._v("正如其名，通信双方使用的密钥是完全相同的，密钥既可以把明文加密成密文，也可以把密文解密成明文。")]),v._v(" "),t("p",[v._v("不过对称加密算法的一大问题就是难以做到把密钥安全的送达给对方。对称加密算法使用到的密钥，需要使用对称加密算法，这样一看就变成死循环了，很明显不行。")]),v._v(" "),t("p",[v._v("常见对称加密算法：DES, 3DES, AES")]),v._v(" "),t("p",[t("strong",[v._v("非对称加密算法（公钥加密算法）")])]),v._v(" "),t("p",[v._v("非对称加密算法使用的密钥对是一个公钥一个私钥。")]),v._v(" "),t("p",[v._v("公钥可以把明文加密成密文，而私钥则是把密文解密成明文。私钥是不能被其他人知道的，而公钥即使第三方拿到了也没有问题。因为最终完成解密的私钥只在你手上，别人只能加密而无法查看密文的内容。")]),v._v(" "),t("p",[v._v("因此，对称加密算法中运送密钥的难题在这里就不会发生了。但是，非对称加密算法在性能上比对称加密算法还是差了许多的，这也是为什么有混合加密算法。")]),v._v(" "),t("p",[v._v("常见非对称加密算法: RSA")]),v._v(" "),t("p",[t("strong",[v._v("混合加密算法")])]),v._v(" "),t("p",[v._v("使用随机生成函数来生成一对密钥，利用公钥对密钥进行加密，这样就能解决密钥的配送难题了。")]),v._v(" "),t("p",[t("strong",[v._v("中间人攻击")])]),v._v(" "),t("p",[v._v("混合加密基本上保证了数据的机密性，只要你能确定你所使用的公钥确实是对方发出的。")]),v._v(" "),t("p",[v._v("通常用户A和B进行加密通信的时候，A会向B发送自己的公钥，然后B利用公钥把对称加密所使用的密钥进行加密发送给A，A再用自己的私钥对密钥进行解密。这样双方接下来就能用密钥进行加密通信了。")]),v._v(" "),t("p",[v._v("但假设这样的场景：")]),v._v(" "),t("p",[v._v("A向B发送自己的公钥途中，公钥被黑客截取。然后黑客把自己的公钥发送给B，B误以为是A的公钥，结果用了黑客的公钥对自己的消息加密发送。黑客获取到了加密后的消息，可以用自己的私钥解密，就获取到了B发送消息的明文了。")]),v._v(" "),t("p",[v._v("又因为黑客截取了A发送的公钥，因此可以用A的公钥把自己想发送的消息加密发送给A。")]),v._v(" "),t("p",[v._v("这样一来，A会误以为黑客是B，B会误以为黑客是A，这就是所谓的中间人攻击。")]),v._v(" "),t("p",[v._v("导致中间人攻击的原因在于：无法确认公钥到底是谁发出的。")]),v._v(" "),t("p",[v._v("这也正是"),t("strong",[v._v("认证")]),v._v("所解决的，下文会解释如何解决中间人攻击。")]),v._v(" "),t("h4",{attrs:{id:"完整性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#完整性"}},[v._v("#")]),v._v(" 完整性")]),v._v(" "),t("p",[t("strong",[v._v("单向哈希函数")])]),v._v(" "),t("p",[v._v("单向哈希函数接受一个任意长度的输入，生成一串固定长度哈希值。一旦输入的值发送一丁点变化，输出的哈希值也会产生巨大的改变。因此可以用来验证数据的完整性。")]),v._v(" "),t("p",[v._v("通信时使用的时候，可以同时把消息和消息经过哈希后的散列值发送给对方。对方只需要在接收到消息后，进行哈希获取散列值进行比对，就能知道消息是否完整。")]),v._v(" "),t("p",[v._v("常见哈希函数：MD5，SHA")]),v._v(" "),t("p",[t("strong",[v._v("消息认证码（MAC）")])]),v._v(" "),t("p",[v._v("消息认证码的生成很像上面介绍的单向哈希函数，不同的是消息认证码的输入是消息和一个对称密钥，生成的值就叫消息认证码（MAC）。")]),v._v(" "),t("p",[v._v("与单向哈希函数对比后，就能知道消息认证码可以看作是与密钥相关联的单项哈希函数。正是因为与密钥相关联，消息认证码不仅仅能做到保证消息的完整性，还能起到认证的作用。（注：消息认证码中使用的密钥并没有起到加密的作用，仅仅是一个输入数而已。而数字签名中使用的到的私钥起到的签名的作用。二者之间是不同的）")]),v._v(" "),t("p",[t("strong",[v._v("数字签名")])]),v._v(" "),t("p",[v._v("使用私钥对消息进行加密（签名），使用公钥对消息进行解密（验证）。")]),v._v(" "),t("p",[v._v("单向哈希函数，消息认证码和数字签名的区别在哪？")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("很明显，单向哈希函数只能验证消息的完整性。")]),v._v(" "),t("p",[v._v("问题简化成消息认证码和数字签名的区别。")])]),v._v(" "),t("li",[t("p",[v._v("二者都能做到验证消息的完整性和认证。")]),v._v(" "),t("p",[v._v("消息认证码是通过比对 消息和对称密钥的运算生成的MAC。")]),v._v(" "),t("p",[v._v("而数字签名是通过比对 私钥对消息的加密生成的签名。")]),v._v(" "),t("p",[v._v("（要注意的是消息认证码中对称密钥的作用并不是加密，而仅仅是一个输入的数）")]),v._v(" "),t("p",[v._v("二者的差别就在于一个用的是对称密钥，一个是非对称密钥。")])])]),v._v(" "),t("p",[v._v("所以使用消息认证码的时候，B可以伪造出一个信息说是A发送的，对于第三方来说，由于A和B的密钥相同，所以无法证伪。")]),v._v(" "),t("p",[v._v("而如果使用数字签名，A和B使用的密钥不同，就不会发生这种事了。")]),v._v(" "),t("p",[t("strong",[v._v("证书")])]),v._v(" "),t("p",[v._v("之前说过了，导致中间人的原因是无法确认公钥到底是谁的，我们所需要解决的问题就是公钥的"),t("strong",[v._v("认证")]),v._v("问题。")]),v._v(" "),t("p",[v._v("我们之前也说过数字签名可以进行消息的认证，而证书实际上使用的就是数字签名来认证。")]),v._v(" "),t("p",[v._v("先解释一下证书的构成：")]),v._v(" "),t("p",[v._v("证书 = 网站的公钥 + CA（Certifi"),t("em",[v._v("ca")]),v._v("te Authority，证书颁发机构）的私钥对网站公钥的签名")]),v._v(" "),t("p",[v._v("当用户访问网站时，并不是直接把公钥发给用户，而是把证书发给用户。二者的最大差别就是证书上除了公钥，还有签名。因此当用户收到证书后，用CA的公钥对签名进行验证，就能知道这个公钥到底是不是网站的公钥了。")]),v._v(" "),t("h4",{attrs:{id:"ssl-tls"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ssl-tls"}},[v._v("#")]),v._v(" SSL/TLS")]),v._v(" "),t("p",[v._v("HTTP和HTTPS只差了一个S，这个S就是SSL/TLS。")]),v._v(" "),t("p",[v._v("如果只使用HTTP协议，无异于在互联网中裸泳，对于数据的加密是必须的。")]),v._v(" "),t("p",[v._v("那么TLS大概是怎么加密的呢？（具体的太过复杂，因此我就讲个大概）")]),v._v(" "),t("p",[v._v("在TCP三次握手之后，服务端和客户端各自生成一个伪随机数传给对方，服务端把证书传给客户端，客户端生成一个"),t("strong",[v._v("预备主密码")]),v._v("（也是个伪随机数）[公钥加密后]发送给服务端。")]),v._v(" "),t("p",[v._v("这个预备主密码和客户端，服务端生成的伪随机数。三个数一起运算出一个"),t("strong",[v._v("主密码")]),v._v("。")]),v._v(" "),t("p",[v._v("主密码是单纯用于本次TLS对话的密码，使用主密码来生成通信过程中要用到的对称密钥，以及用来验证完整性的消息认证码所使用的对称密钥。")]),v._v(" "),t("p",[v._v("老实说整个过程要比这复杂的多，我还是简单讲下关键的一个点。")]),v._v(" "),t("ol",[t("li",[v._v("服务端把证书给客户端")]),v._v(" "),t("li",[v._v("客户端认证证书后，使用公钥来传送预备主密码。")]),v._v(" "),t("li",[v._v("通过两个随机数和预备主密码生成主密码（主密码不用于实际通信，只用于这次SSL对话）")]),v._v(" "),t("li",[v._v("利用主密码生成一对对称密钥用于通信，一对对称密钥用于消息认证码（其实还有对密钥用于啥初始化向量，不懂）")])]),v._v(" "),t("p",[v._v("可以看到SSL/TLS具备了机密性，完整性和认证的功能。")]),v._v(" "),t("p",[v._v("通过"),t("strong",[v._v("证书/数字签名")]),v._v("来实现认证功能，避免了中间人的攻击。")]),v._v(" "),t("p",[v._v("使用生成的"),t("strong",[v._v("对称密钥")]),v._v("来发送消息，实现了机密性。")]),v._v(" "),t("p",[v._v("使用"),t("strong",[v._v("消息认证码")]),v._v("来保证完整性。")]),v._v(" "),t("h3",{attrs:{id:"写在最后"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#写在最后"}},[v._v("#")]),v._v(" 写在最后")]),v._v(" "),t("p",[v._v("没什么想说的，好好活着吧。")])])}),[],!1,null,null,null);_.default=p.exports}}]);