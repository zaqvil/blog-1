(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{338:function(t,e,a){"use strict";a.r(e);var s=a(18),n=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"拷贝"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#拷贝"}},[t._v("#")]),t._v(" 拷贝")]),t._v(" "),a("blockquote",[a("p",[t._v("本文为初学前端时所写，未进行勘误便移植了过来，若有错误请见谅。")])]),t._v(" "),a("p",[t._v("之所以要聊这个话题，得从今天遇到的一个问题说起了。")]),t._v(" "),a("p",[t._v("首先这是一段vue代码")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("export default {\n    data() {\n        return {\n            obj: {\n                a: 'a',\n                b: 'b',\n            }\n        }\n    },\n    computed: {\n        val() {\n            return this.obj\n        }\n    },\n    methods: {\n        click() {\n            delete this.obj.b\n        }\n    }\n}\n")])])]),a("p",[t._v("其实我真正的需求是下面的这个代码，原理上和下面代码差不多，写上面的代码是为了其他人能看得懂。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("//main.js\nconst store = new Vuex.Store({\n\tstate: {\n        obj: {\n            a: 'a',\n            b: 'b',\n        }\n\t}，\n\tmutations: {\n    \tclick(state) {\n        \tdelete state.b\n    \t}\n\t}\n})\n\n//组件内\nexport default {\n\tcomputed: {\n    \tval() {\n        \treturn store.state.obj\n    \t}\n\t},\n\tmethods: {\n    \tclick() {\n        \tstore.commit('clickEvent')\n    \t}\n\t}\n}\n")])])]),a("p",[t._v("简单来说，组件中的计算属性的返回值是依赖于vuex中保存的obj对象的。")]),t._v(" "),a("p",[t._v("我希望得到的效果是，当我删除或增加vuex中保存的对象的属性时，组件中的计算属性返回值也发生相应的改变。")]),t._v(" "),a("p",[t._v("当然结果是事与愿违，因为计算属性是根据依赖而进行缓存的，由于我们做的是给obj对象删除/增加属性， 而不是修改属性，因此vue会判定依赖没有发生改变。")]),t._v(" "),a("p",[t._v("就好像你实例化一个vue类后，再给data中增加一个属性， 这个属性也不会是响应式的。")]),t._v(" "),a("p",[t._v("当然，功能还是要实现的，但我们不一定要直接给对象删除或增加属性，换个思路，我们可以把原先的对象进行克隆，对新对象进行删除/增加属性的操作后再复制给原先的对象。这个操作实际上是修改了对象的引用，因此计算属性会根据依赖的改变而重新进行计算。")]),t._v(" "),a("p",[t._v("那么，就到了本文的正题了，如何进行对象的克隆？")]),t._v(" "),a("h2",{attrs:{id:"object-assign"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#object-assign"}},[t._v("#")]),t._v(" Object.assign()")]),t._v(" "),a("blockquote",[a("p",[a("code",[t._v("Object.assign")]),t._v("方法用于对象的合并，将源对象"),a("strong",[t._v("自身")]),t._v("（source）的所有"),a("strong",[t._v("可枚举属性")]),t._v("，复制到目标对象（target）。")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("const target = { a: 1 };\n\nconst source1 = { b: 2 };\nconst source2 = { c: 3 };\n\nObject.assign(target, source1, source2);\ntarget // {a:1, b:2, c:3}\n")])])]),a("p",[t._v("要注意的地方")]),t._v(" "),a("h4",{attrs:{id:"只拷贝自身的且是可枚举的属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#只拷贝自身的且是可枚举的属性"}},[t._v("#")]),t._v(" 只拷贝自身的且是可枚举的属性")]),t._v(" "),a("h4",{attrs:{id:"浅拷贝"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浅拷贝"}},[t._v("#")]),t._v(" 浅拷贝")]),t._v(" "),a("p",[t._v("如果属性的值是一个对象，那么拷贝得到的就是这个对象的引用")]),t._v(" "),a("h4",{attrs:{id:"取值函数的处理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#取值函数的处理"}},[t._v("#")]),t._v(" "),a("strong",[t._v("取值函数的处理")])]),t._v(" "),a("p",[a("code",[t._v("Object.assign")]),t._v("只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("const source = {\n  get foo() { return 1 }\n};\nconst target = {};\n\nObject.assign(target, source)\n// { foo: 1 }\n")])])]),a("h2",{attrs:{id:"扩展运算符"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#扩展运算符"}},[t._v("#")]),t._v(" 扩展运算符")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("var a = {\n\tfoo: 'foo'\n}\n\n{...a}//{foo: 'foo'}\n")])])]),a("p",[t._v("某种程度上扩展运算符和Object.assign很像。")]),t._v(" "),a("ul",[a("li",[t._v("它们都只拷贝自身的可遍历属性")]),t._v(" "),a("li",[t._v("它们都是浅拷贝")]),t._v(" "),a("li",[t._v("它们对取值函数的处理都不友好")])]),t._v(" "),a("p",[t._v("但无论如何，拥有了这两个方法，我们就能处理很多问题了。")]),t._v(" "),a("p",[t._v("比如最开始的那个问题")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("click() {\n\tlet obj = {...this.obj}\n\tdelete obj.b\n\tthis.obj = obj\n}\n\n//或者\n\nclick() {\n\tlet obj = Object.assign({}, this.obj)\n\tdelete obj.b\n\tthis.obj = obj\n}\n")])])]),a("p",[t._v("问题解决了，我们回到克隆对象本身上。")]),t._v(" "),a("p",[t._v("我们之前所做的，其实都是克隆对象实例的属性，如果想做到完整的克隆对象，就需要克隆对象的原型对象了。")]),t._v(" "),a("p",[t._v("首先介绍几个方法")]),t._v(" "),a("h2",{attrs:{id:"object-create-prototype-descriptors"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#object-create-prototype-descriptors"}},[t._v("#")]),t._v(" Object.create(prototype, descriptors)")]),t._v(" "),a("p",[a("em",[t._v("prototype")])]),t._v(" "),a("p",[t._v("​\t必需。  要用作原型的对象。  可以为 "),a("strong",[t._v("null")]),t._v("。")]),t._v(" "),a("p",[a("em",[t._v("descriptors")])]),t._v(" "),a("p",[t._v("​\t可选。  包含一个或多个属性描述符的 JavaScript 对象。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("Object.create(null)\n// {}\n")])])]),a("p",[t._v("这里返回的是一个没有"),a("code",[t._v("__proto__")]),t._v("属性的完全的空对象。")]),t._v(" "),a("p",[t._v("如果传递了属性描述符的话，函数返回的对象实例会带上那些属性。")]),t._v(" "),a("h2",{attrs:{id:"object-getprototypeof-object-setprototypeof"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#object-getprototypeof-object-setprototypeof"}},[t._v("#")]),t._v(" Object.getPrototypeOf() Object.setPrototypeOf()")]),t._v(" "),a("p",[t._v("字面意思，设置/获取对象的原型对象")]),t._v(" "),a("h2",{attrs:{id:"完全克隆"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#完全克隆"}},[t._v("#")]),t._v(" 完全克隆")]),t._v(" "),a("p",[t._v("摘抄自"),a("a",{attrs:{href:"http://es6.ruanyifeng.com/#docs/object",target:"_blank",rel:"noopener noreferrer"}},[t._v("阮一峰ECMAScript6入门"),a("OutboundLink")],1),t._v("的几种方法")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("const clone1 = {\n    __proto__: Object.getPrototypeOf(obj),\n    ...obj\n}\n\nconst clone2 = Object.assign(\n    Object.create(Object.getPrototypeOf(obj)),\n    obj\n)\n\nconst clone3 = Object.create(\n    Object.getPrototypeOf(obj),\n    Object.getOwnPropertyDescriptors(obj)\n)\n")])])]),a("p",[t._v("这里提一点")]),t._v(" "),a("p",[t._v("Object.getOwnPropertyDescriptors()获取的属性描述符，无论是和Object.defineProperties()还是和Object.create()搭配，都能起到对取值函数的拷贝，很好的弥补了Object.assign()或扩展运算符的不足之处。")]),t._v(" "),a("h3",{attrs:{id:"当然，克隆对象最大的坑就是深克隆（deep-clone）了，本文暂时不做讲解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#当然，克隆对象最大的坑就是深克隆（deep-clone）了，本文暂时不做讲解"}},[t._v("#")]),t._v(" 当然，克隆对象最大的坑就是深克隆（deep clone）了，本文暂时不做讲解~")])])}),[],!1,null,null,null);e.default=n.exports}}]);